#!/usr/bin/env python3
"""
Action Executor Node

Executes action plans generated by the LLM planner using ROS 2 action clients.
Supports plan execution, monitoring, retry, and abort functionality.

Topics:
    Subscribed:
        /planner/action_plan (std_msgs/String) - JSON action plan
        /executor/abort (std_msgs/String) - Abort command

    Published:
        /executor/status (std_msgs/String) - Execution status updates
        /executor/result (std_msgs/String) - Final execution result
        /executor/current_step (std_msgs/String) - Current step info

Parameters:
    max_retries: Maximum retry attempts per step
    step_timeout: Default timeout for each step (seconds)
    abort_on_failure: Whether to abort plan on first failure

Usage:
    ros2 run action_executor executor_node --ros-args \
        -p max_retries:=3 \
        -p step_timeout:=60.0
"""

import json
import time
from typing import Dict, Any, Optional, List, Callable
from dataclasses import dataclass, field
from enum import Enum

import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.callback_groups import ReentrantCallbackGroup
from std_msgs.msg import String, Bool
from geometry_msgs.msg import PoseStamped

# Import action types (may not be available in all environments)
try:
    from nav2_msgs.action import NavigateToPose
    NAV2_AVAILABLE = True
except ImportError:
    NAV2_AVAILABLE = False


class ExecutionState(Enum):
    """Execution states."""
    IDLE = "idle"
    EXECUTING = "executing"
    PAUSED = "paused"
    ABORTING = "aborting"
    COMPLETED = "completed"
    FAILED = "failed"


@dataclass
class StepResult:
    """Result of executing a single step."""
    success: bool
    message: str
    duration: float
    retries: int = 0


@dataclass
class ExecutionResult:
    """Result of complete plan execution."""
    success: bool
    steps_completed: int
    total_steps: int
    duration: float
    error_message: Optional[str] = None
    step_results: List[StepResult] = field(default_factory=list)

    def to_dict(self) -> Dict:
        return {
            'success': self.success,
            'steps_completed': self.steps_completed,
            'total_steps': self.total_steps,
            'duration': self.duration,
            'error_message': self.error_message,
            'step_results': [
                {'success': r.success, 'message': r.message, 'duration': r.duration}
                for r in self.step_results
            ]
        }


class ActionExecutorNode(Node):
    """Execute action plans from LLM planner."""

    def __init__(self):
        super().__init__('action_executor')

        self.callback_group = ReentrantCallbackGroup()

        # Declare parameters
        self.declare_parameter('max_retries', 3)
        self.declare_parameter('step_timeout', 60.0)
        self.declare_parameter('abort_on_failure', True)
        self.declare_parameter('simulate_actions', True)  # For testing without real robot

        self.max_retries = self.get_parameter('max_retries').value
        self.step_timeout = self.get_parameter('step_timeout').value
        self.abort_on_failure = self.get_parameter('abort_on_failure').value
        self.simulate_actions = self.get_parameter('simulate_actions').value

        # Execution state
        self.state = ExecutionState.IDLE
        self.current_plan: Optional[Dict] = None
        self.current_step_index = 0
        self.should_abort = False

        # Action clients (initialize if available)
        self.action_clients: Dict[str, ActionClient] = {}
        self._init_action_clients()

        # Action handlers
        self.action_handlers: Dict[str, Callable] = {
            'navigate_to': self.execute_navigate,
            'approach_object': self.execute_approach,
            'pick_object': self.execute_pick,
            'place_object': self.execute_place,
            'open_gripper': self.execute_gripper,
            'close_gripper': self.execute_gripper,
            'locate_object': self.execute_locate,
            'scan_area': self.execute_scan,
            'identify_object': self.execute_identify,
            'speak': self.execute_speak,
            'ask_confirmation': self.execute_ask_confirmation,
            'wait': self.execute_wait,
            'check_battery': self.execute_check_battery,
            'go_home': self.execute_go_home,
            'emergency_stop': self.execute_emergency_stop,
        }

        # Known locations
        self.locations = {
            'kitchen': {'x': 5.0, 'y': 2.0, 'theta': 0.0},
            'living_room': {'x': 0.0, 'y': 0.0, 'theta': 0.0},
            'bedroom': {'x': -3.0, 'y': 4.0, 'theta': 1.57},
            'office': {'x': 2.0, 'y': -3.0, 'theta': 3.14},
            'home': {'x': 0.0, 'y': 0.0, 'theta': 0.0},
            'user': {'x': 1.0, 'y': 1.0, 'theta': 0.0},  # Default user location
        }

        # Create ROS interfaces
        self.plan_sub = self.create_subscription(
            String,
            '/planner/action_plan',
            self.plan_callback,
            10
        )

        self.abort_sub = self.create_subscription(
            String,
            '/executor/abort',
            self.abort_callback,
            10
        )

        self.status_pub = self.create_publisher(String, '/executor/status', 10)
        self.result_pub = self.create_publisher(String, '/executor/result', 10)
        self.step_pub = self.create_publisher(String, '/executor/current_step', 10)

        self.get_logger().info('Action executor initialized')
        self.get_logger().info(f'Simulation mode: {self.simulate_actions}')

    def _init_action_clients(self):
        """Initialize action clients for available actions."""
        if NAV2_AVAILABLE:
            self.nav_client = ActionClient(
                self, NavigateToPose, '/navigate_to_pose',
                callback_group=self.callback_group
            )
            self.action_clients['navigate_to'] = self.nav_client
            self.get_logger().info('Nav2 action client initialized')

    def plan_callback(self, msg: String):
        """Handle incoming action plan."""
        if self.state == ExecutionState.EXECUTING:
            self.get_logger().warning('Already executing a plan, ignoring new plan')
            return

        try:
            plan = json.loads(msg.data)
        except json.JSONDecodeError as e:
            self.get_logger().error(f'Invalid plan JSON: {e}')
            return

        # Check feasibility
        if not plan.get('feasible', True):
            reason = plan.get('reason', 'Unknown reason')
            self.get_logger().info(f'Plan not feasible: {reason}')
            self.publish_status(f'Cannot execute: {reason}')
            return

        steps = plan.get('steps', [])
        if not steps:
            self.get_logger().warning('Plan has no steps')
            return

        self.current_plan = plan
        self.execute_plan()

    def abort_callback(self, msg: String):
        """Handle abort request."""
        if self.state == ExecutionState.EXECUTING:
            self.should_abort = True
            self.state = ExecutionState.ABORTING
            self.get_logger().info('Abort requested')
            self.publish_status('Aborting execution...')

    def execute_plan(self):
        """Execute the current action plan."""
        if not self.current_plan:
            return

        self.state = ExecutionState.EXECUTING
        self.should_abort = False
        self.current_step_index = 0

        plan = self.current_plan
        steps = plan.get('steps', [])
        goal = plan.get('goal', 'Unknown goal')

        self.get_logger().info(f'Executing plan: {goal} ({len(steps)} steps)')
        self.publish_status(f'Starting: {goal}')

        start_time = time.time()
        step_results: List[StepResult] = []
        steps_completed = 0

        for i, step in enumerate(steps):
            if self.should_abort:
                self.get_logger().info('Execution aborted')
                break

            self.current_step_index = i
            action = step.get('action', 'unknown')
            params = step.get('parameters', {})
            description = step.get('description', action)

            self.get_logger().info(f'Step {i+1}/{len(steps)}: {description}')
            self.publish_status(f'Step {i+1}/{len(steps)}: {description}')
            self.publish_current_step(step)

            # Execute step with retries
            result = self.execute_step_with_retry(action, params)
            step_results.append(result)

            if result.success:
                steps_completed += 1
                self.get_logger().info(f'Step {i+1} completed')
            else:
                self.get_logger().error(f'Step {i+1} failed: {result.message}')
                if self.abort_on_failure:
                    break

        # Calculate total duration
        total_duration = time.time() - start_time

        # Build execution result
        success = (steps_completed == len(steps)) and not self.should_abort
        exec_result = ExecutionResult(
            success=success,
            steps_completed=steps_completed,
            total_steps=len(steps),
            duration=total_duration,
            error_message=None if success else 'Execution incomplete',
            step_results=step_results
        )

        # Publish result
        self.publish_result(exec_result)

        if success:
            self.state = ExecutionState.COMPLETED
            self.publish_status(f'Completed: {goal}')
        else:
            self.state = ExecutionState.FAILED
            self.publish_status(f'Failed: {steps_completed}/{len(steps)} steps completed')

        self.current_plan = None

    def execute_step_with_retry(self, action: str, params: dict) -> StepResult:
        """Execute a step with retry logic."""
        retries = 0
        start_time = time.time()

        while retries <= self.max_retries:
            try:
                success, message = self.execute_step(action, params)

                if success:
                    return StepResult(
                        success=True,
                        message=message,
                        duration=time.time() - start_time,
                        retries=retries
                    )
                else:
                    retries += 1
                    if retries <= self.max_retries:
                        self.get_logger().info(f'Retrying step ({retries}/{self.max_retries})')
                        time.sleep(1.0)  # Brief pause before retry

            except Exception as e:
                self.get_logger().error(f'Step exception: {e}')
                retries += 1

        return StepResult(
            success=False,
            message=f'Failed after {self.max_retries} retries',
            duration=time.time() - start_time,
            retries=retries
        )

    def execute_step(self, action: str, params: dict) -> tuple:
        """Execute a single action step."""
        handler = self.action_handlers.get(action)

        if handler:
            return handler(params)
        else:
            self.get_logger().warning(f'Unknown action: {action}')
            if self.simulate_actions:
                time.sleep(0.5)
                return True, f'Simulated unknown action: {action}'
            return False, f'Unknown action: {action}'

    # === Action Handlers ===

    def execute_navigate(self, params: dict) -> tuple:
        """Execute navigation action."""
        target = params.get('target', '')

        # Look up target location
        if target in self.locations:
            pose = self.locations[target]
        else:
            return False, f'Unknown location: {target}'

        if self.simulate_actions:
            self.get_logger().info(f'[SIM] Navigating to {target}: {pose}')
            time.sleep(2.0)  # Simulate navigation time
            return True, f'Arrived at {target}'

        # Real navigation using Nav2
        if 'navigate_to' not in self.action_clients:
            return False, 'Navigation action client not available'

        # Create goal
        goal = NavigateToPose.Goal()
        goal.pose = PoseStamped()
        goal.pose.header.frame_id = 'map'
        goal.pose.header.stamp = self.get_clock().now().to_msg()
        goal.pose.pose.position.x = pose['x']
        goal.pose.pose.position.y = pose['y']
        goal.pose.pose.orientation.w = 1.0

        # Send and wait for result
        self.nav_client.wait_for_server(timeout_sec=5.0)
        future = self.nav_client.send_goal_async(goal)
        rclpy.spin_until_future_complete(self, future, timeout_sec=5.0)

        goal_handle = future.result()
        if not goal_handle.accepted:
            return False, 'Navigation goal rejected'

        result_future = goal_handle.get_result_async()
        rclpy.spin_until_future_complete(self, result_future, timeout_sec=self.step_timeout)

        return True, f'Arrived at {target}'

    def execute_approach(self, params: dict) -> tuple:
        """Execute approach object action."""
        object_id = params.get('object_id', '')

        if self.simulate_actions:
            self.get_logger().info(f'[SIM] Approaching {object_id}')
            time.sleep(1.5)
            return True, f'Approached {object_id}'

        return False, 'Approach action not implemented'

    def execute_pick(self, params: dict) -> tuple:
        """Execute pick object action."""
        object_id = params.get('object_id', '')
        grasp_type = params.get('grasp_type', 'side')

        if self.simulate_actions:
            self.get_logger().info(f'[SIM] Picking {object_id} with {grasp_type} grasp')
            time.sleep(2.0)
            return True, f'Picked {object_id}'

        return False, 'Pick action not implemented'

    def execute_place(self, params: dict) -> tuple:
        """Execute place object action."""
        target = params.get('target', '')

        if self.simulate_actions:
            self.get_logger().info(f'[SIM] Placing object at {target}')
            time.sleep(1.5)
            return True, f'Placed object at {target}'

        return False, 'Place action not implemented'

    def execute_gripper(self, params: dict) -> tuple:
        """Execute gripper control."""
        if self.simulate_actions:
            self.get_logger().info('[SIM] Gripper action')
            time.sleep(0.5)
            return True, 'Gripper action completed'

        return False, 'Gripper action not implemented'

    def execute_locate(self, params: dict) -> tuple:
        """Execute locate object action."""
        object_type = params.get('object_type', '')

        if self.simulate_actions:
            self.get_logger().info(f'[SIM] Locating {object_type}')
            time.sleep(1.0)
            return True, f'Located {object_type}'

        return False, 'Locate action not implemented'

    def execute_scan(self, params: dict) -> tuple:
        """Execute area scan action."""
        if self.simulate_actions:
            self.get_logger().info('[SIM] Scanning area')
            time.sleep(1.5)
            return True, 'Area scanned'

        return False, 'Scan action not implemented'

    def execute_identify(self, params: dict) -> tuple:
        """Execute identify object action."""
        object_id = params.get('object_id', '')

        if self.simulate_actions:
            self.get_logger().info(f'[SIM] Identifying {object_id}')
            time.sleep(0.5)
            return True, f'Identified {object_id}'

        return False, 'Identify action not implemented'

    def execute_speak(self, params: dict) -> tuple:
        """Execute speak action."""
        message = params.get('message', '')

        self.get_logger().info(f'[SPEAK] "{message}"')

        if self.simulate_actions:
            time.sleep(len(message) * 0.05)  # Rough speech time
            return True, 'Spoken'

        # In real implementation, publish to TTS node
        return True, 'Spoken'

    def execute_ask_confirmation(self, params: dict) -> tuple:
        """Execute ask confirmation action."""
        question = params.get('question', '')

        if self.simulate_actions:
            self.get_logger().info(f'[SIM] Asking: {question}')
            time.sleep(2.0)
            return True, 'User confirmed'

        return False, 'Confirmation action not implemented'

    def execute_wait(self, params: dict) -> tuple:
        """Execute wait action."""
        duration = params.get('duration', 1.0)

        self.get_logger().info(f'Waiting {duration} seconds')
        time.sleep(duration)

        return True, f'Waited {duration}s'

    def execute_check_battery(self, params: dict) -> tuple:
        """Execute battery check action."""
        if self.simulate_actions:
            self.get_logger().info('[SIM] Battery: 85%')
            return True, 'Battery at 85%'

        return False, 'Battery check not implemented'

    def execute_go_home(self, params: dict) -> tuple:
        """Execute go home action."""
        return self.execute_navigate({'target': 'home'})

    def execute_emergency_stop(self, params: dict) -> tuple:
        """Execute emergency stop."""
        self.get_logger().warning('EMERGENCY STOP')

        # In real implementation, publish to emergency stop topic
        if self.simulate_actions:
            return True, 'Emergency stop activated'

        return True, 'Emergency stop activated'

    # === Publishing Methods ===

    def publish_status(self, status: str):
        """Publish execution status."""
        msg = String()
        msg.data = status
        self.status_pub.publish(msg)

    def publish_result(self, result: ExecutionResult):
        """Publish execution result."""
        msg = String()
        msg.data = json.dumps(result.to_dict())
        self.result_pub.publish(msg)

    def publish_current_step(self, step: dict):
        """Publish current step info."""
        msg = String()
        msg.data = json.dumps(step)
        self.step_pub.publish(msg)


def main(args=None):
    rclpy.init(args=args)
    node = ActionExecutorNode()

    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
